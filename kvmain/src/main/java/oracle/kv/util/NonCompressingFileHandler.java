/*-
 * Copyright (C) 2011, 2025 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.util;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;

/**
 * A logging FileHandler that does not compress rotated log files itself, but
 * that checks for files compressed or renamed earlier by a
 * CompressingFileHandler and deletes them as needed. This class is used to
 * handle the case where compression is enabled and then disabled. If no
 * compressed or renamed files are found, sets a flag to skip future checks.
 */
public class NonCompressingFileHandler extends BasicCompressingFileHandler {

    /**
     * Whether to check for files to delete. Disable until the class is fully
     * initialized, and also after no compressed or renamed files are found.
     */
    private volatile boolean checksEnabled;

    /**
     * Creates a FileHandler that cleans up existing compressed or renamed
     * rotated log files. The pattern can only use the %g directive, which must
     * appear only once. No other directives are permitted. If the limit is 0,
     * file sizes are not limited, so there is no log rotation. The
     * extraLogging parameter controls whether logging produced by this class
     * itself should be included in the log. It should be enabled for files in
     * standard logging format, but not for ones that use specialized formats
     * where these log records would not fit in.
     *
     * @param pattern the pattern for naming the output file
     * @param limit the maximum number of bytes to write to any one file
     * @param count the number of files to use
     * @param extraLogging whether to log additional log records with
     * information generated by this class
     * @throws IOException if there are IO problems opening files
     * @throws IllegalArgumentException if pattern is an empty string, contains
     * '%' directives other than a single '%g', or does not contain a '%g'
     * directive, if limit is less than 0, or if count is less than 1
     */
    public NonCompressingFileHandler(String pattern,
                                     int limit,
                                     int count,
                                     boolean extraLogging)
        throws IOException
    {
        super(pattern, limit, count, extraLogging);

        checksEnabled = true;

        /* Check for extra files on startup after instance is initialized */
        checkFiles();
        addExtraLogMessage(String.format("Created with limit=%d" +
                                         " count=%d",
                                         limit,
                                         count),
                           null /* exception */);
    }

    /**
     * Check for renamed files to delete when opening a new logging file
     */
    @Override
    protected synchronized void setOutputStream(OutputStream out) {
        checkFiles();
        super.setOutputStream(out);
    }

    /**
     * Check for renamed files to delete.
     */
    void checkFiles() {
        if (!checksEnabled) {
            return;
        }

        /* Collect matching files */
        final List<MatchInfo> matches = new ArrayList<>();
        try (final DirectoryStream<Path> paths = newDirectoryStream()) {
            for (final Path path : paths) {
                final Matcher matcher = regexPattern.matcher(path.toString());
                if (matcher.matches()) {
                    matches.add(new MatchInfo(path, matcher));
                }
            }
        } catch (IOException e) {
            unexpected("reading directory", e);
            return;
        }

        /* Sort files in natural order with oldest first */
        matches.sort(null);

        /*
         * Delete any partially compressed files, and note if any files are
         * compressed or renamed
         */
        String lastCreationTime = null;
        int lastUnique = 0;
        MatchInfo tmp = null;
        MatchInfo gz = null;
        boolean foundDateFormat = false;
        for (final Iterator<MatchInfo> i = matches.iterator();
             i.hasNext(); ) {
            final MatchInfo current = i.next();
            final String version = current.getVersion();
            final Matcher dateMatcher = DATE_PATTERN.matcher(version);
            if (!dateMatcher.matches()) {
                continue;
            }
            foundDateFormat = true;

            final String creationTime = dateMatcher.group(1);
            final String uniqueString = dateMatcher.group(2);
            final int unique =
                (uniqueString != null) ? Integer.parseInt(uniqueString) : 0;

            /*
             * Check if creation time or unique value changed from last
             * iteration
             */
            if ((lastCreationTime == null) ||
                !lastCreationTime.equals(creationTime) ||
                (lastUnique != unique)) {
                lastCreationTime = creationTime;
                lastUnique = unique;
                tmp = null;
                gz = null;
            }

            if (current.isTemp()) {
                tmp = current;
            } else {
                gz = current;
            }

            /*
             * If .tmp and .gz files are both present for the same creation
             * time and unique value, then delete the .gz file, which is an
             * incompletely compressed file.
             */
            if ((tmp != null) && (gz != null)) {
                deleteFile(gz.path);
                i.remove();
            }
        }

        /*
         * If no date format files are found, then all the compressed and
         * renamed files are gone -- no need to check again.
         */
        if (!foundDateFormat) {
            checksEnabled = false;
            return;
        }

        /*
         * Delete compressed or renamed files if they exceed the count. Note
         * that the current log file could be significantly larger than the
         * original file size limit if compression has been disabled. This
         * problem won't be corrected until that file becomes old enough to be
         * deleted.
         */
        int deleteCount = matches.size() - getCount();
        if (deleteCount > 0) {
            for (final MatchInfo current : matches) {
                final String version = current.getVersion();
                final Matcher dateMatcher = DATE_PATTERN.matcher(version);

                /* Only delete compressed or renamed files */
                if (!dateMatcher.matches()) {
                    continue;
                }
                deleteFile(current.path);
                deleteCount--;
                if (deleteCount <= 0) {
                    break;
                }
            }
        }
    }

    /** Returns whether checks for files to delete are enabled. */
    boolean getChecksEnabled() {
        return checksEnabled;
    }

    /** Enable file deletion checks, for testing. */
    void setChecksEnabled() {
        checksEnabled = true;
    }

    @Override
    String getLogPrefix() {
        return "Non-compressing file handler: ";
    }
}
