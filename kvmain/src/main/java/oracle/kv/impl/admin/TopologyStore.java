/*-
 * Copyright (C) 2011, 2025 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.impl.admin;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import oracle.kv.impl.admin.AdminDatabase.DB_TYPE;
import oracle.kv.impl.admin.AdminDatabase.LongKeyDatabase;
import oracle.kv.impl.admin.AdminStores.AdminStore;
import oracle.kv.impl.admin.topo.RealizedTopology;
import oracle.kv.impl.admin.topo.TopologyCandidate;
import oracle.kv.impl.topo.Topology;
import oracle.kv.impl.util.SerializationUtil;

import com.sleepycat.bind.tuple.StringBinding;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Environment;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Transaction;

/**
 * Topologies are stored in in two forms:
 *
 * 1)a collection of TopologyCandidates, which are named topologies created by
 *   the user.These are in a PrimaryIndex&lt;String, TopologyCandidate&gt;,
 *   where the key is the candidate name.
 *
 * 2)a bounded collection of historical RealizedTopology(s), which keeps track
 *   of all topologies that have deployed by administrative commands. This is
 *   in a PrimaryIndex&lt;Long, RealizedTopology&gt;, where the key is a
 *   timestamp.  Realized topologies optionally refer to their originating
 *   candidate.
 *
 * The indices used are:
 *
 * PrimaryIndex&lt;String, TopologyCandidate&gt;: list of candidates:
 * PrimaryIndex&lt;Long, RealizedTopology&gt;: Realized topologies, ordered by
 *                            timestamp. The current topology is the latest one.
 *
 * The life cycle of a topology is this:
 *
 * - The user creates a named topology candidate using the "topology create
 * <i>name</i> ...". The resulting topology may be deployed, or further
 * manipulated with one of the topology commands that modify layouts, such as
 * topology redistribute, topology rebalance, etc.
 *
 * - This candidate is stored in the candidates collection, and can be viewed,
 * listed, or deleted.
 *
 * - When the user has a topology she likes, she can choose to deploy it with
 * the plan deploy-topology <i>name</i> command. Deployments are composed of
 * multiple tasks, and the realized topology is saved periodically as the
 * deployment executes. Since plans can be interrupted, canceled, or incur
 * errors, the realized topology may never reach the precise state of the named
 * topology candidate. The current topology of the store is saved
 * as the last record of the historical topology collection.
 *
 * The historical collection is an audit trail of deployed topologies. It is
 * meant as an audit trail/debugging aid. There is one record per invocation of
 * the deploy-topology command, which preserves the final version of the
 * topology as generated by that command. The historical collection is bounded
 * by time, and versions of the topology that are older than the expiry date
 * are pruned. In a fairly stable store, there may be few deploy-topology
 * commands, and a minimum number of records are kept.
 */
public class TopologyStore extends AdminStore {

    public static TopologyStore getReadOnlyInstance(Logger logger,
                                                    Environment env) {
        return new TopologyStore(logger, env, Integer.MAX_VALUE, true);
    }

    private final LongKeyDatabase<RealizedTopology> historyDb;
    private final AdminDatabase<String, TopologyCandidate> candidateDb;

    /**
     * The maximum number of topo changes that are to be retained in realized
     * topologies that are being saved.
     */
    private final int maxTopoChanges;

    /**
     * Start time of the last realized topology from the historical collection.
     * Since the start time is the primary key for the RealizedTopology
     * instance, it's important that the timestamp for new realizedTopologies
     * always ascend. If there is some clock skew between nodes in the Admin
     * replication group, there is the possibility that the start millis is <=
     * to the last saved RealizedTopology. Cache the last start time to use wen
     * generating a unique timestamp.
     */
    private long lastStartMillis = 0;

    public TopologyStore(Logger logger,
                         Environment env,
                         int maxTopoChanges,
                         boolean readOnly) {
        super(logger);
        this.maxTopoChanges = maxTopoChanges;
        historyDb = new LongKeyDatabase<>(DB_TYPE.TOPOLOGY_HISTORY,
                                          logger, env, readOnly);
        candidateDb = new AdminDatabase<String, TopologyCandidate>(
                                        DB_TYPE.TOPOLOGY_CANDIDATE, logger,
                                        env, readOnly) {
            @Override
            protected DatabaseEntry keyToEntry(String key) {
                final DatabaseEntry keyEntry = new DatabaseEntry();
                StringBinding.stringToEntry(key, keyEntry);
                return keyEntry;
            }};
    }

    /**
     * Returns the list of topologies in the history.
     *
     * @param concise if true generate a concise string for each topology
     * @return the list of topologies in the history
     */
    public List<String> displayHistory(boolean concise) {
        return displayHistory(null, concise);
    }

    /**
     * Gets the current realized topology from the historical store using the
     * specified transaction and return a copy as a new topology instance.
     *
     * @param txn a transaction
     * @return the current realized topology
     */
    Topology getTopology(Transaction txn) {
        final RealizedTopology rt = getCurrentRealizedTopology(txn);
        return (rt == null) ? null : rt.getTopology();
    }

    /**
     * Returns true if the specified candidate exists in the store.
     */
    boolean candidateExists(Transaction txn, String candidateName) {
        return getCandidate(txn, candidateName) != null;
    }

    /**
     * Validates the specified proposed start time.
     * Since the start time is the primary key for the historical collection,
     * ensure that the start time for any new realized topology is greater than
     * the start time recorded for the current topology. Due to clock skew in
     * the HA rep group, conceivably the start time could fail to advance if
     * there is admin rep node failover.
     *
     * @param proposedStartTime
     * @return the start time to use
     */
    synchronized long validateStartTime(long proposedStartTime) {
        /* The proposed start time is greater, as expected. */
        if (proposedStartTime > lastStartMillis) {
            lastStartMillis = proposedStartTime;
            return proposedStartTime;
        }

        /*
         * For some reason, the proposed start time has receded. Manufacture
         * a new start time. This should be fairly infrequent.
         */
        lastStartMillis++;
        logger.log(Level.INFO,
                   "TopologyStore: proposedStartTime of {0} is less than " +
                   "cached time, so use topoStore lastStartTime of {1}",
                   new Object[]{proposedStartTime, lastStartMillis});
        return lastStartMillis;
    }

    /**
     * Refreshes the cached last start time stored in store for validating
     * new realized topologies.
     */
    void initCachedStartTime(Transaction txn) {
        final RealizedTopology rt = getCurrentRealizedTopology(txn);
        lastStartMillis = (rt == null) ? 0 : rt.getStartTime();
    }

    void pruneChanges(Topology topology) {
        topology.pruneChanges(Integer.MAX_VALUE, maxTopoChanges);
    }

    @Override
    public void close() {
        historyDb.close();
        candidateDb.close();
    }

    /**
     * Puts the specified realized topology into the store using the specified
     * transaction.
     *
     * @param txn a transaction
     * @param rt the realized topology to store
     */
    public void putTopology(Transaction txn, RealizedTopology rt) {
        pruneChanges(rt.getTopology());
        historyDb.put(txn, rt.getStartTime(), rt, false);
    }

    /**
     * Returns a list of names of all candidates. If there are no named
     * topologies, an empty list is returned.
     *
     * @param txn a transaction
     * @return the list of candidate names
     */
    public List<String> getCandidateNames(Transaction txn) {
        final List<String> names = new ArrayList<>();
        final DatabaseEntry keyEntry = new DatabaseEntry();
        final DatabaseEntry valueEntry = new DatabaseEntry();
        valueEntry.setPartial(0, 0, true);
        try (final Cursor cursor = candidateDb.openCursor(txn)) {
            while (true) {
                final OperationStatus status =
                                        cursor.getNext(keyEntry,
                                                       valueEntry,
                                                       LockMode.DEFAULT);
                if (status != OperationStatus.SUCCESS) {
                    return names;
                }
                names.add(StringBinding.entryToString(keyEntry));
            }
        }
    }

    /**
     * Gets the specified topology candidate from the store using the specified
     * transaction.
     *
     * @param txn a transaction
     * @param candidateName a candidate name
     * @return the candidate or null
     */
    TopologyCandidate getCandidate(Transaction txn, String candidateName) {
        return candidateDb.get(txn, candidateName, LockMode.DEFAULT,
                               TopologyCandidate.class);
    }

    /**
     * Puts the specified topology candidate into the store using the specified
     * transaction.
     *
     * @param txn a transaction
     * @param candidate the candidate to store
     */
    void putCandidate(Transaction txn, TopologyCandidate candidate) {
        pruneChanges(candidate.getTopology());
        candidateDb.put(txn, candidate.getName(), candidate, false);
    }

    /**
     * Deletes the specified topology candidate from the store using the
     * specified transaction.
     *
     * @param txn a transaction
     * @param candidateName a candidate name
     */
    void deleteCandidate(Transaction txn, String candidateName) {
        candidateDb.delete(txn, candidateName);
    }

    List<String> displayHistory(Transaction txn, boolean concise) {
        final List<String> display = new ArrayList<>();
        final DatabaseEntry keyEntry = new DatabaseEntry();
        final DatabaseEntry valueEntry = new DatabaseEntry();
        try (final Cursor cursor = historyDb.openCursor(txn)) {
            while (true) {
                final OperationStatus status =
                                        cursor.getNext(keyEntry,
                                                       valueEntry,
                                                       LockMode.DEFAULT);
                if (status != OperationStatus.SUCCESS) {
                    return display;
                }
                final RealizedTopology rt =
                        SerializationUtil.getObject(valueEntry.getData(),
                                                    RealizedTopology.class);
                display.add(rt.display(concise));
            }
        }
    }

    public RealizedTopology getCurrentRealizedTopology(Transaction txn) {
        try (final Cursor cursor = historyDb.openCursor(txn)) {
            final DatabaseEntry keyEntry = new DatabaseEntry();
            final DatabaseEntry valueEntry = new DatabaseEntry();
            final OperationStatus status = cursor.getLast(keyEntry,
                                                          valueEntry,
                                                          LockMode.DEFAULT);
            return (status == OperationStatus.SUCCESS) ?
                       SerializationUtil.getObject(valueEntry.getData(),
                                                   RealizedTopology.class) :
                       null;
        }
    }
}
