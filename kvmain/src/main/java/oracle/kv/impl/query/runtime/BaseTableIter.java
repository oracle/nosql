/*-
 * Copyright (C) 2011, 2025 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.impl.query.runtime;

import static oracle.kv.impl.util.SerialVersion.JSON_COLLECTION_VERSION;
import static oracle.kv.impl.util.SerialVersion.QUERY_VERSION_16;
import static oracle.kv.impl.util.SerialVersion.QUERY_VERSION_17;
import static oracle.kv.impl.util.SerializationUtil.readPackedLong;
import static oracle.kv.impl.util.SerializationUtil.writePackedLong;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import oracle.kv.Direction;
import oracle.kv.impl.api.table.DisplayFormatter;
import oracle.kv.impl.api.table.FieldDefImpl;
import oracle.kv.impl.api.table.FieldValueImpl;
import oracle.kv.impl.api.table.IndexImpl;
import oracle.kv.impl.api.table.NameUtils;
import oracle.kv.impl.api.table.RecordValueImpl;
import oracle.kv.impl.api.table.TableImpl;
import oracle.kv.impl.query.QueryException.Location;
import oracle.kv.impl.query.compiler.ExprBaseTable;
import oracle.kv.impl.query.compiler.ExprInOp.In3BindInfo;
import oracle.kv.impl.query.compiler.ExprVar;
import oracle.kv.impl.query.compiler.FuncCompOp;
import oracle.kv.impl.query.compiler.FunctionLib.FuncCode;
import oracle.kv.impl.util.SerializationUtil;
import oracle.kv.table.FieldRange;

/**
 * BaseTableIter performs table scans via the primary or a secondary index of
 * the table.
 *
 * The query plan generated by the compiler includes instances of BaseTableIter,
 * but the actual work is done by a ServerTableIter instance, which is created
 * during BaseTableIter.open(). After the creation of the worker iter, the
 * open/next/reset/close methods of BaseTableIter are propagated to that
 * worker. The reason for this separation is that ServerTableIter uses
 * server-side classes, which are not available in the client jar.
 *
 * ServerIterFactory is an interface whose createTableIterator() method
 * does the job of creating the worker iter. Specifically, when the RCB is
 * created at the server, an instance of ServerIterFactoryImpl is also created
 * and stored in the RCB. Then, during BaseTableIter.open() the
 * ServerIterFactoryImpl stored in the RCB is used to create the
 * ServerTableIter.
 */
public class BaseTableIter extends PlanIter {

    public static class TableIterState extends PlanIterState {

        PlanIter theWorkerIter;

        public TableIterState(PlanIter worker) {
            theWorkerIter = worker;
        }
    }

    protected final long[] theTableIds; // added in QUERY_VERSION_16

    protected final String theNamespace;

    protected final String[] theTableNames; // changed in QUERY_VERSION_6

    protected final String[] theTableAliases; // added in QUERY_VERSION_9

    /* The schema varions of the tables */
    protected final int[] theTableVersions; // added in QUERY_VERSION_16

    protected final int theNumAncestors; // added in QUERY_VERSION_6

    protected final int theNumDescendants; // added in QUERY_VERSION_6

    protected final long theIndexId; // added in QUERY_VERSION_16

    protected final String theIndexName;

    /*
     * The definition of the data returned by this iterator.
     */
    protected final FieldDefImpl theTypeDef;

    /*
     * The direction of the table scan
     */
    protected final Direction theDirection;

    /*
     * Each entry in this array holds a, potentialy partial or even empty,
     * primary key. For each such key K, a scan of the primary index will
     * be performed over the index entries that match K (if K is empty all
     * index entries match). All entries in the array have the same size().
     * thePrimKeys will be null if a secondary index must be used to access
     * the table.
     *
     * Note: Some of the column values stored in these prim keys may be
     * placeholder values, whose real values will be computed during runtime
     * (see ServerTableIter.computeIndexScans()).
     *
     * Note: the keys are stored here as RecordValues, instead of PrimaryKeys,
     * for 2 reasons:
     * - When we serialize the BaseTableIter, we don't want to serialize a
     *   PrimaryKey, because that contains a TableImpl as well.
     * - thePrimKeys may include "placeholder" values that correspod to external
     *   variables. As a result, a new primary key instance must be created and
     *   stored in the plan state during the open() method. This new instance
     *   will actually be an instance of PrimaryKey.
     */
    protected final RecordValueImpl[] thePrimKeys;

    /*
     * Each entry in this array holds a, potentialy partial or even empty,
     * secondary key. For each such key K, a scan of the secondary index will
     * be performed over the index entries that match K (if K is empty all
     * index entries match). All entries in the array have the same size().
     * theSecKeys will be null if the primary index must be used to access
     * the table.
     *
     * Note: Some of the column values stored in these sec keys may be
     * placeholder values, whose real values will be computed during runtime
     * (see ServerTableIter.computeIndexScans()).
     *
     * Note: theSecKey is stored here as a RecordValue, instead of IndexKey,
     * for the same reasons described above for thePrimKey.
     */
    protected final RecordValueImpl[] theSecKeys;

    /*
     * This array mirrors thePrimKeys or theSecKeys. If theRanges[i] != null,
     * then the i-th index scan is further restricted by theRanges[i].
     * 
     * More specifically, assume that:
     * (a) theSecKeys[i] = K,
     * (b) K is partial, with values for the first n secondary-key columns
     * (c) theRanges[i] = R and R != null
     * then R holds start and/or end values for the (n+1)-th secondary-key
     * column. And the i-th index scan will be over index entries that match
     * K on their first n columns and whose (n+1)-th column is between R.start
     * and R.end.
     *
     * Note: Some of the column values stored in these ranges may be
     * placeholder values, whose real values will be computed during runtime
     * (see ServerTableIter.computeIndexScans()).
     */
    protected final FieldRange[] theRanges;

    /*
     * The iterators computing values that must replace the placeholdrer values,
     * if any, inside thePrimKeys/theSecKeys and/or theRanges.
     * Added in v20.1
     */
    protected PlanIter[] theExternalKeysIters;

    /*
     * Maps the positions of placeholder values in thePrimKeys/theSecKeys and/or
     * theRanges to iters in theExternalKeysIters.
     *
     * There is one entry per index scan. Each entry, say the i-th entry, is an
     * array whose size is equal to the size of the RecordValues in thePrimKeys
     * or theSecKeys, plus 2 if theRanges[i] != null. If theExternalKeysMap[i][j] = k
     * and k >= 0, then the j-th column inside thePrimKeys[i] or theSecKeys[i] or
     * theRanges[i] is a placeholder, whose actual value is computed by
     * theExternalKeysIters[k].
     * Added in v20.1.
     */
    protected final int[][] theExternalKeysMap;

    /*
     * Added in v20.1.
     */
    protected final In3BindInfo[] theIn3BindInfos;

    /*
     * Added in v20.1.
     */
    protected final boolean theHaveINstartstopPreds;

    /*
     * Used before v20.1, instead of theExternalKeysIters and theExternalKeysMap
     */
    protected PlanIter[][] thePushedExternals;

    /*
     * thePredIters has an entry for each table. The entry is non-null if
     * there is a predicate that filters index or table rows during the scan
     * of the associated table. For the target table, the pred is always an
     * index-only pred that has been pushed down from the WHERE clause. For
     * the non-target tables, the pred is the ON pred, if any, associated
     * with the table.
     */
    protected PlanIter[] thePredIters; // changed in QUERY_VERSION_6

    /*
     * For each tale, it tells whether the index used to access the table
     * is a covering index or not.
     */
    protected final boolean[] theUsesCoveringIndex;

    /*
     * True if the table will be accessed via a multikey index in a way that
     * may generate duplicate table rows. Such duplicates should be eliminated.
     *
     * added in QUERY_VERSION_2
     */
    protected final boolean theEliminateIndexDups;

    protected final boolean theIsUpdate; // added in QUERY_VERSION_5

    /* added in 18.3 */
    protected final boolean theIsDelete;

    protected final int thePosInJoin; // added in QUERY_VERSION_17

    /*
     * theTupleRegs are used differently depending on whether the iter accesses
     * a single table or implements a NESTED TABLES clause. In the 1st case, it
     * stores the columns of the current table row, so the number of regs is
     * equal to the number of table columns. In the 2nd case, the current table
     * row from each table, so the number of regs is equal to the number of
     * tables.
     */
    protected final int[] theTupleRegs;

    /*
     * theIndexTupleRegs are used for the target table only, when the index used
     * to access the table is a secondary one and the index is covering or the
     * query has index-only  filtering preds. In these cases, theIndexTupleRegs
     * store the columns of the current index entry.
     */
    protected int[] theIndexTupleRegs; // added in QUERY_VERSION_6

    protected int theIndexResultReg; // added in QUERY_VERSION_6

    protected short theVersion; // added in QUERY_VERSION_6

    /**
     * Constructor used by compiler during code generation.
     *
     * primKey and secKey will be both null if no predicates were pushed to
     * either the primary or any secondary index. In this case, an empty
     * primary key is created by this constructor, so that the table will be
     * accessed via a full scan of the primary index. If a range exists,
     * either primKey or secKey will be non-null to indicate whether the
     * range is over the primary or a secondary index. But the given key will
     * be empty, if no equality predicates were pushed to the index.
     */
    public BaseTableIter(
        ExprBaseTable e,
        int resultReg,
        int[] tupleRegs,
        TableImpl table,
        List<TableImpl> tables,
        List<String> aliases,
        int numAncestors,
        int numDescendants,
        Direction dir,
        IndexImpl index,
        List<RecordValueImpl> indexKeys,
        List<FieldRange> ranges,
        PlanIter[] externalKeysIters,
        boolean[] coveringIndexes,
        boolean eliminateIndexDups,
        int posInJoin,
        boolean isUpdate,
        boolean isDelete) {

        super(e, resultReg);

        int numTables = tables.size();
        theTableIds = new long[numTables];
        theNamespace = table.getInternalNamespace();
        theTableNames = new String[numTables];
        theTableAliases = new String[numTables];
        theTableVersions = new int[numTables];

        for (int i = 0; i < numTables; ++i) {
            theTableIds[i] = tables.get(i).getId();
            theTableNames[i] = tables.get(i).getFullName();
            theTableAliases[i] = ExprVar.
                                 createVarNameFromTableAlias(aliases.get(i));
            theTableVersions[i] = tables.get(i).getTableVersion();
        }
        theNumAncestors = numAncestors;
        theNumDescendants = numDescendants;

        theTypeDef = e.getType().getDef();

        theDirection = dir;

        int numScans = 1;

        if (index == null && indexKeys == null) {
            theSecKeys = null;
            theIndexId = 0;
            theIndexName = null;
            thePrimKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];
            thePrimKeys[0] = table.createPrimaryKey();
            theRanges[0] = null;

        } else if (index == null) {
            theSecKeys = null;
            theIndexId = 0;
            theIndexName = null;
            numScans = ranges.size();
            thePrimKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];

            for (int i = 0; i < numScans; ++i) {
                thePrimKeys[i] = table.createPrimaryKey();
                thePrimKeys[i].copyFrom(indexKeys.get(i));
                theRanges[i] = ranges.get(i);
            }

        } else {
            thePrimKeys = null;
            theIndexId = index.getId();
            theIndexName = index.getName();
            numScans = ranges.size();
            theSecKeys = new RecordValueImpl[numScans];
            theRanges = new FieldRange[numScans];

            for (int i = 0; i < numScans; ++i) {
                theSecKeys[i] = indexKeys.get(i).clone();
                theRanges[i] = ranges.get(i);
            }
        }

        theExternalKeysIters = externalKeysIters;
        theExternalKeysMap = e.getBindKeysMap();
        theHaveINstartstopPreds = e.getHaveINstartstopPreds();
        ArrayList<In3BindInfo> in3bis = e.getIn3BindInfos();
        if (in3bis != null) {
            theIn3BindInfos = new In3BindInfo[in3bis.size()];
            in3bis.toArray(theIn3BindInfos);
        } else {
            theIn3BindInfos = null;
        }

        thePredIters = new PlanIter[theTableNames.length];

        theUsesCoveringIndex = coveringIndexes;
        theEliminateIndexDups = eliminateIndexDups;
        thePosInJoin = (posInJoin < 0 ? 0 : posInJoin);
        theIsUpdate = isUpdate;
        theIsDelete = isDelete;

        theTupleRegs = tupleRegs;
    }

    /**
     * Constructor called during creation of ServerTableIter.
     */
    protected BaseTableIter(BaseTableIter parent) {
        this(parent.theStatePos,
             parent.theResultReg,
             parent.theLocation,
             parent.theTableIds,
             parent.theNamespace,
             parent.theTableNames,
             parent.theTableAliases,
             parent.theTableVersions,
             parent.thePredIters,
             parent.theNumAncestors,
             parent.theNumDescendants,
             parent.theIndexId,
             parent.theIndexName,
             parent.theTypeDef,
             parent.theDirection,
             parent.thePrimKeys,
             parent.theSecKeys,
             parent.theRanges,
             parent.theUsesCoveringIndex,
             parent.theEliminateIndexDups,
             parent.thePosInJoin,
             parent.theIsUpdate,
             parent.theIsDelete,
             parent.theExternalKeysIters,
             parent.theExternalKeysMap,
             parent.theIn3BindInfos,
             parent.thePushedExternals,
             parent.theHaveINstartstopPreds,
             parent.theTupleRegs,
             parent.theIndexResultReg,
             parent.theIndexTupleRegs,
             parent.theVersion);
    }

    private BaseTableIter(int statePos,
                          int resultReg,
                          Location location,
                          long[] tableIds,
                          String namespace,
                          String[] tableNames,
                          String[] tableAliases,
                          int[] tableVersions,
                          PlanIter[] predIters,
                          int numAncestors,
                          int numDescendants,
                          long indexId,
                          String indexName,
                          FieldDefImpl typeDef,
                          Direction direction,
                          RecordValueImpl[] primKeys,
                          RecordValueImpl[] secKeys,
                          FieldRange[] ranges,
                          boolean[] usesCoveringIndex,
                          boolean eliminateIndexDups,
                          int posInJoin,
                          boolean isUpdate,
                          boolean isDelete,
                          PlanIter[] externalKeysIters,
                          int[][] externalKeysMap,
                          In3BindInfo[] in3BindInfos,
                          PlanIter[][] pushedExternals,
                          boolean haveINstartstopPreds,
                          int[] tupleRegs,
                          int indexResultReg,
                          int[] indexTupleRegs,
                          short version) {
        super(statePos, resultReg, location);

        theTableIds = tableIds;
        theNamespace = namespace;
        theTableNames = tableNames;
        theTableAliases = tableAliases;
        theTableVersions = tableVersions;
        thePredIters = predIters;
        theNumAncestors = numAncestors;
        theNumDescendants = numDescendants;
        theIndexId = indexId;
        theIndexName = indexName;

        theTypeDef = typeDef;

        theDirection = direction;

        thePrimKeys = primKeys;
        theSecKeys = secKeys;
        theRanges = ranges;

        theUsesCoveringIndex = usesCoveringIndex;
        theEliminateIndexDups = eliminateIndexDups;
        thePosInJoin = posInJoin;
        theIsUpdate = isUpdate;
        theIsDelete = isDelete;

        theExternalKeysIters = externalKeysIters;
        theExternalKeysMap = externalKeysMap;

        theIn3BindInfos = in3BindInfos;
        thePushedExternals = pushedExternals;
        theHaveINstartstopPreds = haveINstartstopPreds;
        theTupleRegs = tupleRegs;
        theIndexResultReg = indexResultReg;
        theIndexTupleRegs = indexTupleRegs;

        theVersion = version;
    }

    BaseTableIter(DataInput in, short serialVersion) throws IOException {

        super(in, serialVersion);

        theVersion = serialVersion;

        if (serialVersion >= QUERY_VERSION_16) {
            theTableIds = PlanIter.deserializeLongArray(in, serialVersion);
            theTableVersions = PlanIter.deserializeIntArray(in, serialVersion);
            theIndexId = readPackedLong(in);
        } else {
            theTableIds = null;
            theTableVersions = null;
            theIndexId = 0;
        }

        theNamespace = SerializationUtil.readString(in, serialVersion);

        theTableNames = PlanIter.deserializeStringArray(in, serialVersion);
        theTableAliases = PlanIter.
            deserializeStringArray(in, serialVersion);

        theNumAncestors = in.readInt();
        theNumDescendants = in.readInt();

        theIndexName = SerializationUtil.readString(in, serialVersion);

        theTypeDef = (FieldDefImpl)deserializeFieldDef(in, serialVersion);
        short ordinal = readOrdinal(in, Direction.VALUES_COUNT);
        theDirection = Direction.valueOf(ordinal);

        final int numScans = readPositiveInt(in);

        if (theIndexName == null) {
            thePrimKeys = new RecordValueImpl[numScans];
            for (int i = 0; i < numScans; ++i) {
                thePrimKeys[i] = deserializeKey(in, serialVersion);
            }
            theSecKeys = null;
        } else {
            thePrimKeys = null;
            theSecKeys = new RecordValueImpl[numScans];
            for (int i = 0; i < numScans; ++i) {
                theSecKeys[i] = deserializeKey(in, serialVersion);
            }
        }

        theRanges = new FieldRange[numScans];
        for (int i = 0; i < numScans; ++i) {
            theRanges[i] = deserializeFieldRange(in, serialVersion);
        }

        theUsesCoveringIndex = PlanIter.deserializeBooleanArray(in);

        theEliminateIndexDups = in.readBoolean();

        if (serialVersion >= QUERY_VERSION_17) {
            thePosInJoin = in.readInt();
        } else {
            thePosInJoin = 0;
        }

        theIsUpdate = in.readBoolean();
        theIsDelete = in.readBoolean();

        thePushedExternals = null;
        theHaveINstartstopPreds = in.readBoolean();
        theExternalKeysIters = deserializeIters(in, serialVersion);

        if (theExternalKeysIters.length > 0) {

            theExternalKeysMap = new int[numScans][];
            for (int i = 0; i < numScans; ++i) {
                theExternalKeysMap[i] = deserializeIntArray(in, serialVersion);
            }

            int numIn3bis = SerializationUtil.readSequenceLength(in);
            if (numIn3bis < 0) {
                theIn3BindInfos = null;
            } else {
                theIn3BindInfos = new In3BindInfo[numIn3bis];
                for (int i = 0; i < numIn3bis; ++i) {
                    theIn3BindInfos[i] = new In3BindInfo(in, serialVersion);
                }
            }
        } else {
            theExternalKeysIters = null;
            theExternalKeysMap = null;
            theIn3BindInfos = null;
        }

        thePredIters = PlanIter.deserializeIters(in, serialVersion);

        theTupleRegs = deserializeIntArray(in, serialVersion);

        theIndexResultReg = readPositiveInt(in, true);
        theIndexTupleRegs = deserializeIntArray(in, serialVersion);
    }

    @Override
    public void writeFastExternal(DataOutput out, short serialVersion)
            throws IOException {

        super.writeFastExternal(out, serialVersion);

        if (serialVersion >= QUERY_VERSION_16) {
            PlanIter.serializeLongArray(theTableIds, out, serialVersion);
            PlanIter.serializeIntArray(theTableVersions, out, serialVersion);
            writePackedLong(out, theIndexId);
        }

        SerializationUtil.writeString(out, serialVersion, theNamespace);

        PlanIter.serializeStringArray(theTableNames, out, serialVersion);
        PlanIter.serializeStringArray(theTableAliases, out,
                                      serialVersion);
        out.writeInt(theNumAncestors);
        out.writeInt(theNumDescendants);

        SerializationUtil.writeString(out, serialVersion, theIndexName);
        /*
         * As of JSON Collection implementation theTypeDef can be a Map
         * instead of Record, make sure the other side can handle it
         */
        if (theTypeDef.isMap() && serialVersion < JSON_COLLECTION_VERSION) {
            throw new IllegalArgumentException(
                "JSON Collection tables are not supported in serial" +
                " version: " +  serialVersion);
        }
        serializeFieldDef(theTypeDef, out, serialVersion);
        out.writeShort(theDirection.ordinal());

        if (theIndexName == null) {
            out.writeInt(thePrimKeys.length);
            for (RecordValueImpl pk : thePrimKeys) {
                serializeKey(pk, out, serialVersion);
            }
        } else {
            out.writeInt(theSecKeys.length);
            for (RecordValueImpl sk : theSecKeys) {
                serializeKey(sk, out, serialVersion);
            }
        }

        for (FieldRange fr : theRanges) {
            serializeFieldRange(fr, out, serialVersion);
        }

        PlanIter.serializeBooleanArray(theUsesCoveringIndex, out);

        out.writeBoolean(theEliminateIndexDups);

        if (serialVersion >= QUERY_VERSION_17) {
            out.writeInt(thePosInJoin);
        }

        out.writeBoolean(theIsUpdate);
        out.writeBoolean(theIsDelete);

        out.writeBoolean(theHaveINstartstopPreds);
        serializeIters(theExternalKeysIters, out, serialVersion);

        if (theExternalKeysIters != null) {

            for (int[] arr : theExternalKeysMap) {
                PlanIter.serializeIntArray(arr, out, serialVersion);
            }

            SerializationUtil.writeArrayLength(out, theIn3BindInfos);
            if (theIn3BindInfos != null) {
                for (int i = 0; i < theIn3BindInfos.length; ++i) {
                    theIn3BindInfos[i].writeFastExternal(out,
                                                         serialVersion);
                }
            }
        }

        serializeIters(thePredIters, out, serialVersion);

        serializeIntArray(theTupleRegs, out, serialVersion);

        out.writeInt(theIndexResultReg);
        serializeIntArray(theIndexTupleRegs, out, serialVersion);
    }

    @Override
    public PlanIterKind getKind() {
        return PlanIterKind.TABLE;
    }

    @Override
    public int[] getTupleRegs() {
        return theTupleRegs;
    }

    public void setPredIter(int tablePos, PlanIter iter) {
        thePredIters[tablePos] = iter;
    }

    protected PlanIter getTargetTablePred() {
        if (thePredIters.length > 0) {
            return thePredIters[theNumAncestors];
        }
        return null;
    }

    public void setIndexRegs(int resultReg, int[] tupleRegs) {
        theIndexResultReg = resultReg;
        theIndexTupleRegs = tupleRegs;
    }

    @Override
    public void open(RuntimeControlBlock rcb) {

        PlanIter worker = rcb.getServerIterFactory().createTableIter(rcb, this);
        worker.open(rcb);

        if (theIndexName != null) {
            rcb.setUsesIndex();
        }
    }

    @Override
    public boolean next(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);

        if (state.theWorkerIter != null) {
            return state.theWorkerIter.next(rcb);
        }

        state.done();
        return false;
    }

    @Override
    public void reset(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);
        if (state == null) {
            return;
        }

        if (state.theWorkerIter != null) {
            state.theWorkerIter.reset(rcb);
        }
    }

    @Override
    public void close(RuntimeControlBlock rcb) {

        TableIterState state = (TableIterState)rcb.getState(theStatePos);
        if (state == null) {
            return;
        }

        if (state.theWorkerIter != null) {
            state.theWorkerIter.close(rcb);
        }

    }

    @Override
    protected void displayContent(
        StringBuilder sb,
        DisplayFormatter formatter,
        boolean verbose) {

        formatter.indent(sb);
        sb.append("\"target table\" : \"");
        sb.append(NameUtils.makeQualifiedName(theNamespace,
                                              theTableNames[theNumAncestors]));
        sb.append("\",\n");

        if (theTableAliases != null) {
            formatter.indent(sb);
            sb.append("\"row variable\" : \"");
            sb.append(theTableAliases[theNumAncestors]);
            sb.append("\",\n");
        }

        formatter.indent(sb);
        sb.append("\"index used\" : ");

        if (thePrimKeys != null) {
            sb.append("\"primary index\",\n");
        } else {
            sb.append("\"").append(theIndexName).append("\",\n");
        }

        formatter.indent(sb);
        sb.append("\"covering index\" : ");
        sb.append(theUsesCoveringIndex[theNumAncestors]);
        sb.append(",\n");

        if (theIndexTupleRegs != null) {
            formatter.indent(sb);
            sb.append("\"index row variable\" : \"");
            sb.append(theTableAliases[theNumAncestors] + "_idx");
            sb.append("\",\n");
        }

        if (thePrimKeys != null) {
            displayIndexScans(sb, formatter, thePrimKeys);
        } else {
            displayIndexScans(sb, formatter, theSecKeys);
        }

        if (theEliminateIndexDups) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"duplicate elimination\" : true");
        }

        if (theExternalKeysIters != null) {
            sb.append(",\n");
            displayPushedExternals(sb, formatter, verbose);
        }

        if (theNumAncestors > 0) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"ancestor tables\" : [\n");
            formatter.incIndent();
            for (int i = 0; i < theNumAncestors; ++i) {
                formatter.indent(sb);
                sb.append("{ \"table\" : \"").append(theTableNames[i]);
                if (theTableAliases != null) {
                    sb.append("\", \"row variable\" : \"").append(theTableAliases[i]);
                }
                sb.append("\", \"covering primary index\" : ");
                sb.append(theUsesCoveringIndex[i]).append(" }");
                if (i < theNumAncestors - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            formatter.indent(sb);
            sb.append("]");
        }

        if (theNumDescendants > 0) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"descendant tables\" : [\n");
            formatter.incIndent();
            for (int i = theNumAncestors + 1; i < theTableNames.length; ++i) {
                formatter.indent(sb);
                sb.append("{ \"table\" : \"").append(theTableNames[i]);
                if (theTableAliases != null) {
                    sb.append("\", \"row variable\" : \"").append(theTableAliases[i]);
                }
                sb.append("\", \"covering primary index\" : ");
                sb.append(theUsesCoveringIndex[i]).append(" }");
                if (i < theTableNames.length - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            sb.append("\n");
            formatter.indent(sb);
            sb.append("]");
        }

        if (thePredIters != null) {

            if (thePredIters[theNumAncestors] != null) {
                sb.append(",\n");
                formatter.indent(sb);
                sb.append("\"index filtering predicate\" :\n");
                thePredIters[theNumAncestors].display(sb, formatter, verbose);
            }

            for (int i = 0; i < theTableNames.length; ++i) {

                if (i == theNumAncestors || thePredIters[i] == null) {
                    continue;
                }

                sb.append(",\n");
                formatter.indent(sb);
                sb.append("\"ON Predicate for table ");
                sb.append(theTableNames[i]).append("\" : \n");
                thePredIters[i].display(sb, formatter, verbose);
            }
        }
        sb.append(",\n");
        formatter.indent(sb);
        sb.append("\"position in join\" : ").append(thePosInJoin);
    }

    void displayIndexScans(
        StringBuilder sb,
        DisplayFormatter formatter,
        RecordValueImpl[] keys) {

        //formatter.indent(sb);
        //sb.append("\"index scans direction\" : \"");
        //sb.append(theDirection).append("\",\n");

        formatter.indent(sb);
        sb.append("\"index scans\" : [\n");
        formatter.incIndent();

        for (int i = 0; i < theRanges.length; ++i) {

            formatter.indent(sb);
            sb.append("{\n");
            formatter.incIndent();

            formatter.indent(sb);
            sb.append("\"equality conditions\" : ");
            sb.append(keys[i]);
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"range conditions\" : ");
            if (theRanges[i] == null) {
                sb.append("{}");
            } else {
                theRanges[i].display(sb);
            }
            sb.append("\n");

            formatter.decIndent();
            formatter.indent(sb);
            sb.append("}");

            if (i < theRanges.length - 1) {
                sb.append(",");
            }
            sb.append("\n");
        }

        formatter.decIndent();
        formatter.indent(sb);
        sb.append("]");
    }

    private void displayPushedExternals(
        StringBuilder sb,
        DisplayFormatter formatter,
        boolean verbose) {

        formatter.indent(sb);
        sb.append("\"key bind expressions\" : [\n");

        formatter.incIndent();
        for (int i = 0; i < theExternalKeysIters.length; ++i) {

            PlanIter iter = theExternalKeysIters[i];
            if (iter != null) {
                iter.display(sb, formatter, verbose);
            } else {
                formatter.indent(sb);
                sb.append("null");
            }
            if (i < theExternalKeysIters.length - 1) {
                sb.append(",\n");
            }
        }
        formatter.decIndent();
        sb.append("\n");
        formatter.indent(sb);
        sb.append("],\n");

        formatter.indent(sb);
        sb.append("\"map of key bind expressions\" : [\n");

        formatter.incIndent();
        for (int i = 0; i < theExternalKeysMap.length; ++i) {
            int[] arr = theExternalKeysMap[i];
            formatter.indent(sb);
            sb.append(PlanIter.printIntArray(arr));
            if (i < theExternalKeysMap.length - 1) {
                sb.append(",\n");
            }
        }
        sb.append("\n");
        formatter.decIndent();
        formatter.indent(sb);
        sb.append("]");

        if (theIn3BindInfos != null) {

            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"bind info for in3 operator\" : [\n");

            formatter.incIndent();
            for (int i = 0; i < theIn3BindInfos.length; ++i) {
                formatter.indent(sb);
                theIn3BindInfos[i].display(sb, formatter);
                if (i < theIn3BindInfos.length - 1) {
                    sb.append(",\n");
                }
            }
            formatter.decIndent();
            sb.append("\n");
            formatter.indent(sb);
            sb.append("]");
        }
    }

    @Override
    void displayRegs(StringBuilder sb, DisplayFormatter formatter) {

        super.displayRegs(sb, formatter);

        if (theIndexTupleRegs != null) {
            sb.append(",\n");
            formatter.indent(sb);
            sb.append("\"Index entry registers\" : ");
            sb.append("[ ").append(theIndexResultReg).append(", [ ");
            for (int i = 0; i < theIndexTupleRegs.length; ++i) {
                sb.append(theIndexTupleRegs[i]);
                if (i < theIndexTupleRegs.length - 1) {
                    sb.append(", ");
                }
            }
            sb.append(" ] ]");
        }
    }

    static protected FieldValueImpl castValueToIndexKey(
        TableImpl table,
        IndexImpl index,
        int keyPos,
        FieldValueImpl val,
        FuncCode opcode) {

        if (index != null) {
            return FuncCompOp.castConstInCompOp(
                index.getFieldDef(keyPos),
                index.getIndexPath(keyPos).isJson(), /*allowJsonNull*/
                false, /*nullable*/
                true, /*scalar*/
                val,
                opcode,
                false/*strict*/);
        }

        return FuncCompOp.castConstInCompOp(
            table.getPrimKeyColumnDef(keyPos),
            false, /*allowJsonNull*/
            false, /*nullable*/
            true, /*scalar*/
            val,
            opcode,
            false/*strict*/);
    }
}
