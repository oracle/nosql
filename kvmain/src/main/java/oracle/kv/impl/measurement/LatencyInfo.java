/*-
 * Copyright (C) 2011, 2025 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.impl.measurement;

import static java.util.concurrent.TimeUnit.NANOSECONDS;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;

import oracle.kv.impl.util.FormatUtils;
import oracle.nosql.common.sklogger.measure.LatencyElement;

import com.google.gson.JsonObject;
import com.sleepycat.utilint.Latency;


/**
 * A wrapper for measurements generated by LatencyStat
 */
public class LatencyInfo implements Serializable {

    /*
     * ZEROS are used for filling out .csv files when a latency measurement
     * hasn't been taken.
     */
    public static final String ZEROS = "0,0,0,0,0,0,0,0";
    public static final LatencyInfo ZERO_MEASUREMENT = new LatencyInfo();

    private static final long serialVersionUID = 1L;

    /* An id which indicates which PerfStatType should be used. */
    private final int perfStatId;
    /*
     * TODO: Make this field final and remove readObject method with the 23.1
     * release.
     */
    private volatile LatencyResult latencyNanos;
    /*
     * TODO: remove these with the 23.1 release.
     */
    @SuppressWarnings("unused")
    private final Latency latency = new Latency(0);

    /* The time span covered by this measurement */
    private final long startMillis;
    private final long endMillis;

    public LatencyInfo(PerfStatType perfType,
                       long startMillis,
                       long endMillis,
                       LatencyElement.Result result) {
        this(perfType, startMillis, endMillis, new LatencyResult(result));
    }

    public LatencyInfo(PerfStatType perfStatType,
                       long startMillis,
                       long endMillis,
                       LatencyResult result) {
        this.perfStatId = perfStatType.getId();
        this.startMillis = startMillis;
        this.endMillis = endMillis;
        this.latencyNanos = result;
    }

    private LatencyInfo() {
        this(PerfStatType.NOP_INT, 0, 0, new LatencyResult());
    }

    public long getThroughputPerSec() {
        long elapsedMillis = endMillis - startMillis;

        if (elapsedMillis == 0) {
            return 0;
        }

        long longOps = latencyNanos.getOperationCount();
        long throughput = (longOps * 1000)/elapsedMillis;

        if (throughput > 0) {
            return throughput;
        }
        if (longOps > 0) {

            /*
             * The throughput might be 0 if a very few number of operations
             * were executed, and the resulting fraction rounded down to
             * 0. That would be very confusing, so return 1.
             */
            return 1;
        }
        return 0;
    }

    public static String getCSVHeader(String opName) {
        String prefix = '"' + opName + "\n";
        String names = (
            prefix + "TotalOps" + '"' + "," +
            prefix + "PerSec" + '"' + "," +
            prefix + "TotalReq" + '"' + "," +
            prefix + "Min" + '"' + "," +
            prefix + "Max" + '"' + "," +
            prefix + "Avg" + '"' + "," +
            prefix + "95th" + '"' + "," +
            prefix + "99th" + '"').intern();
        return names;
    }

    /*
     * NOTE: the ZEROS static string should match this number of columns
     * generated.
     */
    public String getCSVStats() {
        return
            latencyNanos.getOperationCount() + "," +
            getThroughputPerSec() + "," +
            latencyNanos.getRequestCount() + "," +
            NANOSECONDS.toMillis(latencyNanos.getMin()) + ","+
            NANOSECONDS.toMillis(latencyNanos.getMax()) + ","+
            NANOSECONDS.toMillis(latencyNanos.getAverage()) + ","+
            NANOSECONDS.toMillis(latencyNanos.getPercent95()) + ","+
            NANOSECONDS.toMillis(latencyNanos.getPercent99());
    }

    public int getPerfStatId() {
        return perfStatId;
    }

    public PerfStatType getPerfStatType() {
        return PerfStatType.getType(perfStatId);
    }

    @Override
    public String toString() {
        PerfStatType type = PerfStatType.getType(perfStatId);

        /*
         * If this measurement has been rolled up, the 95th and 99th are
         * always zero, since those cannot be combined without the original
         * LatencyStat histogram. Omit those from the display.
         */
        String latencyVals =
            "perSec=" + getThroughputPerSec() +
            " totalOps=" + latencyNanos.getOperationCount() +
            " totalReq=" + latencyNanos.getRequestCount() +
            " min=" + NANOSECONDS.toMillis(latencyNanos.getMin()) +
            " max=" + NANOSECONDS.toMillis(latencyNanos.getMax()) +
            " avg=" + NANOSECONDS.toMillis(latencyNanos.getAverage());
        if (latencyNanos.hasValidPercentile()) {
            latencyVals +=
                " 95th=" + NANOSECONDS.toMillis(latencyNanos.getPercent95()) +
                " 99th=" + NANOSECONDS.toMillis(latencyNanos.getPercent99());
            if (latencyNanos.getOverflowCount() > 0) {
                latencyVals += " overflow=" +
                    latencyNanos.getOverflowCount();
            }
        }

        return type +
        " (" + FormatUtils.formatTimeMillis(endMillis) + ") " + latencyVals;
    }

    public JsonObject toJson() {
        final JsonObject result = latencyNanos.toJson();
        addJsonProperties(result);
        return result;
    }

    private void addJsonProperties(JsonObject result) {
        result.addProperty("type", getPerfStatType().toString());
        result.addProperty("perSec", getThroughputPerSec());
        result.addProperty("startTime", startMillis);
        result.addProperty("endTime", endMillis);
    }

    public JsonObject toJsonMillis() {
        final JsonObject result = latencyNanos.toJson();
        addJsonProperties(result);
        return result;
    }

    public long getStart() {
        return startMillis;
    }

    public long getEnd() {
        return endMillis;
    }

    public LatencyResult getLatency() {
        return latencyNanos;
    }

    /**
     * Initialize the null fields because the object was serialized from a
     * version prior to 20.2 when the field was added.
     */
    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException {

        in.defaultReadObject();
        if (latencyNanos == null) {
            latencyNanos = new LatencyResult();
        }
    }
}
