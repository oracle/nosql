/*-
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 2011, 2025 Oracle and/or its affiliates.  All rights reserved.
 *
 */

package oracle.kv.impl.admin;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import oracle.kv.TestBase;
import oracle.kv.impl.admin.param.Parameters;
import oracle.kv.impl.admin.param.StorageNodeParams;
import oracle.kv.impl.admin.plan.Plan;
import oracle.kv.impl.api.table.NameUtils;
import oracle.kv.impl.api.table.TableImpl;
import oracle.kv.impl.api.table.TableMetadata;
import oracle.kv.impl.client.admin.ExecutionInfo;
import oracle.kv.impl.query.compiler.Translator;
import oracle.kv.impl.sna.StorageNodeAgent;
import oracle.kv.impl.systables.SysTableDescriptor;
import oracle.kv.impl.systables.SysTableRegistry;
import oracle.kv.impl.systables.TableStatsPartitionDesc;
import oracle.kv.impl.topo.DatacenterId;
import oracle.kv.impl.topo.DatacenterType;
import oracle.kv.impl.util.PortFinder;
import oracle.kv.impl.util.SerialVersion;
import oracle.kv.impl.util.StorageNodeUtils;
import oracle.kv.impl.util.TestUtils;
import oracle.kv.table.FieldDef;
import oracle.kv.table.Index;
import oracle.kv.table.Table;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Tests the DdlHandler.  This test creates a simple store and directly
 * operates on the Admin instance to test DdlHanlder.
 */
public class DdlTest extends TestBase {

    static AdminTestConfig atc;
    static private StorageNodeAgent[] snas;
    static private PortFinder[] portFinders;
    static private Admin admin;

    /*
     * This test implements some things in static methods that TestBase does in
     * non-static state, so reproduce some of that here.  This is done statically
     * to avoid the time/cost of re-creating stores on each test case.
     */
    static private final String storeName = "kvtest-DdlTest";
    static private final int startPort = 13250;
    static private final int haRange = 8;
    static private final int numSNs = 3;


    static final String userTable =
        "CREATE TABLE Users COMMENT \"users table\" (" +
        "id INTEGER, firstName STRING, lastName STRING, PRIMARY KEY (id))";
    static final String userTableIfNot =
        "CREATE TABLE IF NOT EXISTS Users" +
        "(id INTEGER, firstName STRING, lastName STRING, PRIMARY KEY (id))";
    static final String addressTable =
        "CREATE TABLE Users.Address" +
        "(type INTEGER, streetName STRING, city STRING, PRIMARY KEY (type)," +
        "months MAP(INTEGER), " +
        "mapOfRec MAP(RECORD(a INTEGER, s STRING)))";
    static final String userTableWithAddress =
        "CREATE TABLE UsersWithAddress" +
        "(id INTEGER, firstName STRING, lastName STRING, PRIMARY KEY (id), " +
        "address RECORD(street STRING, city STRING))";
    static final String tableWithConstraints =
        "CREATE TABLE Constraints" +
        "(" +
        "ival INTEGER," +
        "lval LONG," +
        "fval FLOAT," +
        "dval DOUBLE DEFAULT 78.5," +
        "sval STRING DEFAULT \"xyz\","+
        "day ENUM (monday, tuesday, wednesday)," +
        "bval BINARY," +
        "fixedbval BINARY(5)," +
        "PRIMARY KEY (SHARD(ival), lval, fval)" +
        ")";

    /*
     * Alter statements
     */
    static final String addUserField =
        "ALTER TABLE Users (ADD age INTEGER)";
    static final String dropAddAddressField =
        "ALTER TABLE Users.Address(DROP city, ADD town STRING)";
    static final String dropAddAddressField1 =
        "ALTER TABLE UsersWithAddress(DROP address.city, " +
        "ADD address.town STRING)";
    static final String modifyUserIdIdentity =
        "ALTER TABLE Users(MODIFY id GENERATED ALWAYS AS IDENTITY(START WITH 50))";
    static final String addAddressIdentity =
        "ALTER TABLE Users.Address(" +
            "ADD addrNo LONG GENERATED BY DEFAULT ON NULL AS IDENTITY)";
    /* this should fail because the field is indexed */
    static final String dropIndexedAddressField =
        "ALTER TABLE UsersWithAddress(DROP address.street)";
    static final String badAlterNoField =
        "ALTER TABLE Users(DROP no_such_field)";

    /*
     * Describe statements
     */
    static final String showTables = "SHOW AS JSON TABLES";
    static final String showIndexes = "SHOW INDEXES ON users";
    static final String showTable = "SHOW AS JSON TABLE users.address";
    static final String showAsJsonIndexes = "SHOW AS JSON INDEXES ON users";

    static final String describeUser = "DESCRIBE TABLE users";
    static final String describeUserJson = "DESCRIBE AS JSON TABLE users";

    static final String describeAddress = "DESCRIBE TABLE users.address";
    static final String describeAddressJson =
        "DESCRIBE AS JSON TABLE users.address";

    static final String describeNameIndex =
        "DESCRIBE INDEX NameIndex ON users";
    static final String describeNameIndexJson =
        "DESCRIBE AS JSON INDEX NameIndex ON users";

    static final String describeCityIndex =
        "DESCRIBE INDEX City ON users.address";
    static final String describeCityIndexJson =
        "DESCRIBE AS JSON INDEX City ON users.address";

    static final String describeCityIndex1 =
        "DESCRIBE INDEX City ON UsersWithAddress";
    static final String describeCityIndex1Json =
        "DESCRIBE AS JSON INDEX City ON UsersWithAddress";

    static final String describeFields1 =
        "DESCRIBE TABLE users (firstName, lastName)";
    static final String describeFields1Json =
        "DESCRIBE AS JSON TABLE users (firstName, lastName)";

    static final String describeFields2 =
        "DESCRIBE TABLE UsersWithAddress (address.city)";
    static final String describeFields2Json =
        "DESCRIBE AS JSON TABLE UsersWithAddress (address.city)";

    static final String describeFields3 =
        "DESCRIBE TABLE users.address (months, mapOfRec, mapOfRec.values().a)";
    static final String describeFields3Json =
        "DESCRIBE AS JSON TABLE users.address (months, mapOfRec, mapOfRec.values().a)";

    static final String[] describeStatements = {
        showTables, showIndexes, showAsJsonIndexes,
        showTable, describeUser, describeUserJson,
        describeAddress, describeAddressJson,
        describeNameIndex, describeNameIndexJson,
        describeCityIndex, describeCityIndexJson,
        describeCityIndex1, describeCityIndex1Json,
        describeFields1, describeFields1Json,
        describeFields2, describeFields2Json,
        describeFields3, describeFields3Json
    };

    /*
     * create/drop indexes and drop tables
     */
    static final String nameIndex =
        "CREATE INDEX NameIndex ON Users (lastName) COMMENT \"name index\"";
    static final String nameIndexIfNot =
        "CREATE INDEX IF NOT EXISTS NameIndex ON Users (lastName) " +
        "COMMENT \"name index\"";
    static final String cityIndex =
        "CREATE INDEX City ON Users.Address (city) COMMENT \"city index\"";
    static final String userCityIndex =
        "CREATE INDEX City ON UsersWithAddress (address.city)";
    static final String userStreetIndex =
        "CREATE INDEX City ON UsersWithAddress (address.street)";

    static final String dropAddress = "DROP TABLE Users.Address";
    static final String dropAddressIfExists =
        "DROP TABLE IF EXISTS Users.Address";
    static final String dropUsers = "DROP TABLE Users";
    static final String dropUsersIfExists = "DROP TABLE IF EXISTS Users";
    static final String dropConstraints = "DROP TABLE Constraints";

    static final String dropNameIndex = "DROP INDEX NameIndex ON Users";
    static final String dropNameIndexIfExists =
        "DROP INDEX IF EXISTS NameIndex ON Users";
    static final String dropCityIndex = "DROP INDEX City ON Users.Address";
    static final String dropCityIndexIfExists =
        "DROP INDEX IF EXISTS City ON Users.Address";

    static final String[] createIndexStatements = {
        nameIndex, nameIndexIfNot, cityIndex, userCityIndex
    };

    static final String[] createStatements = {
        userTable,
        addressTable,
        tableWithConstraints,
        userTableWithAddress
    };

    static final String[] dropStatements = {
        dropAddress,
        dropUsers,
        dropConstraints
    };

    @BeforeClass
    public static void staticSetUp()
        throws Exception {

        TestUtils.clearTestDirectory();
        initStorageNodes();
    	atc = new AdminTestConfig(storeName, portFinders[0]);
        runStaticSetup();
    }

    @AfterClass
    public static void staticTearDown()
        throws Exception {

        for (StorageNodeAgent sna : snas) {
            if (sna != null) {
                sna.shutdown(true, true);
            }
        }
    }

    @Override
    @Before
    public void setUp()
        throws Exception {

        removeAllTables();
    }

    @Override
    @After
    public void tearDown()
        throws Exception {

        removeAllTables();
    }

    @Test
    public void testBasic() {

        for (String statement : createStatements) {
            executeStatement(statement, true);
        }
        assertTableExists("Users", true);
        assertTableExists("Users.Address", true);
        assertTableExists("Constraints", true);

        executeStatement(userTableIfNot, true);
        assertTableComment("Users", "users table");

        assertIndexExists("Users", "NameIndex", false);
        assertIndexExists("Users.Address", "City", false);
        for (String statement : createIndexStatements) {
            executeStatement(statement, true);
        }

        assertIndexExists("Users", "NameIndex", true);
        assertIndexExists("Users.Address", "City", true);
        executeStatement(dropNameIndex, true);
        executeStatement(dropNameIndexIfExists, true);
        executeStatement(dropNameIndex, false);
        assertIndexExists("Users", "NameIndex", false);
        executeStatement(dropCityIndex, true);
        executeStatement(dropCityIndexIfExists, true);
        executeStatement(dropCityIndex, false);
        assertIndexExists("Users.Address", "City", false);

        for (String statement : dropStatements) {
            executeStatement(statement, true);
        }
        assertTableExists("Users", false);
        assertTableExists("Users.Address", false);
        assertTableExists("Constraints", false);

        /*
         * Try some drops of non-existent tables and state.
         */
        executeStatement(dropUsersIfExists, true);
        executeStatement(dropAddressIfExists, true);
        executeStatement(dropUsers, false);
    }

    /*
     * Alter statements
     */
    @Test
    public void testAlter() {

        for (String statement : createStatements) {
            executeStatement(statement, true);
        }

        /* add an index on a record that will be altered */
        executeStatement(userStreetIndex, true);

        assertTableExists("Users", true);
        assertTableExists("Users.Address", true);
        assertTableExists("Constraints", true);

        /* this will fail */
        executeStatement(badAlterNoField, false);

        assertFieldExists("Users", "age", false);
        executeStatement(addUserField, true);
        assertFieldExists("Users", "age", true);

        assertFieldExists("Users.Address", "town", false);
        assertFieldExists("Users.Address", "city", true);
        executeStatement(dropAddAddressField, true);
        assertFieldExists("Users.Address", "town", true);
        assertFieldExists("Users.Address", "city", false);

        /*
         * Attempt to drop indexed field.  This should fail.
         */
        assertFieldExists("UsersWithAddress", "address.street", true);
        executeStatement(dropIndexedAddressField, false);

        /*
         * Add/drop nested field.
         */
        assertFieldExists("UsersWithAddress", "address.city", true);
        executeStatement(dropAddAddressField1, true);
        assertFieldExists("UsersWithAddress", "address.town", true);
        assertFieldExists("UsersWithAddress", "address.city", false);
    }

    /*
     * Describe and show statements
     */
    @Test
    public void testDescribeShow() {

        executeStatement(showTables, true);

        /*
         * Run the create and createIndex statements to populate the store
         * with tables and indexes to work with.
         */
        for (String statement : createStatements) {
            executeStatement(statement, true);
        }

        for (String statement : createIndexStatements) {
            executeStatement(statement, true);
        }

        /*
         * Now test the describe statements themselves.
         */
        for (String statement : describeStatements) {
            executeStatement(statement, true);
        }

        /*
         * Test describe table with identity
         */
        executeStatement(modifyUserIdIdentity, true);
        DdlHandler ddl = executeStatement(describeUserJson, true);
        String ret = ddl.getResultString();
        assertTrue(ret, ret != null &&
                        ret.contains("\"sequence\"") &&
                        ret.contains("\"start\" : 50"));

        executeStatement(addAddressIdentity, true);
        ddl = executeStatement(describeAddressJson, true);
        ret = ddl.getResultString();
        assertTrue(ret, ret != null &&
                        ret.contains("\"sequence\""));

        /* Describe system tables */
        int n = 0;
        StringBuilder sb = new StringBuilder();
        for (SysTableDescriptor desc: SysTableRegistry.descriptors) {
            sb.setLength(0);

            /* describe [as json ] table SYS$xxx */
            sb.append(((n++ % 1) == 0 ? "DESC TABLE " : "DESC AS JSON TABLE "));
            sb.append(desc.getTableName());
            executeStatement(sb.toString(), true);

            /* describe table SYS$xxx(field1, field2 ...) */
            boolean first = true;
            sb.append("(");
            for (String field : desc.buildTable().getPrimaryKey()) {
                if (!first) {
                    sb.append(", ");
                } else {
                    first = false;
                }
                sb.append(field);
            }
            sb.append(")");
            executeStatement(sb.toString(), true);
        }
    }

    @Test
    public void testShowTablesWithNamespace() {
        final String namespace = "testNS";
        final String userTableWithAddressName =
            NameUtils.makeQualifiedName(namespace, "UsersWithAddress");

        executeStatement(userTable, true);
        executeStatement("CREATE NAMESPACE " + namespace, true);
        executeStatement(userTableWithAddress, namespace, true);

        DdlHandler ddl = executeStatement(showTables, true);
        String ret = ddl.getResultString();
        assertTrue(ret.contains("SYS$"));
        assertTrue(ret.contains("Users"));
        assertTrue(ret.contains(userTableWithAddressName));

        ddl = executeStatement(showTables, "sysdefault", true);
        ret = ddl.getResultString();
        assertTrue(ret.contains("SYS$"));
        assertTrue(ret.contains("Users"));
        assertTrue(ret.contains(userTableWithAddressName));

        ddl = executeStatement(showTables, namespace, true);
        ret = ddl.getResultString();
        assertFalse(ret.contains("SYS$"));
        assertTrue(ret.contains("\"namespace\": \"" + namespace + "\""));
        assertTrue(ret.contains("[\"UsersWithAddress\"]"));
    }

    /*
     * Use of duplicate names in tables.  This is technically a table only
     * test but it's easier to use the DDL.
     * TEST:
     * o child table names (TODO)
     *   This is enforced by the system.
     */
    @Test
    public void testDuplicateNames() {
        /* duplicate Record */
        final String dupRecord =
            "CREATE TABLE dupRec(name STRING, address RECORD(name STRING, " +
            "city STRING), nested RECORD(address RECORD(id INTEGER))," +
            " PRIMARY KEY(name))";
        /* duplicate Enum */
        final String dupEnum =
            "CREATE TABLE dupEnum(name STRING, e1 enum(a), " +
            "nested RECORD(e1 enum(a)), " +
            " PRIMARY KEY(name))";
        /* duplicate FixedBinary */
        final String dupFixedBinary =
            "CREATE TABLE dupFixedBin(name STRING, bin BINARY(4), " +
            "nested RECORD(bin BINARY(6)), " +
            " PRIMARY KEY(name))";
        /* duplicate names but different types */
        final String dupMixedType =
            "CREATE TABLE mixed(name STRING, foo BINARY(4), " +
            "nested RECORD(foo ENUM(a)), " +
            " PRIMARY KEY(name))";

        /* Collection of fixed binary.  Make sure name generation works */
        final String collectionOfBinary =
            "CREATE TABLE binaryTable(name STRING, " +
            "arr ARRAY(BINARY(6))," +
            "arr1 ARRAY(BINARY(6))," +
            "PRIMARY KEY(name))";

        /* Collection of enum.  Make sure name generation wor1ks */
        final String collectionOfEnum =
            "CREATE TABLE enumTable(name STRING, " +
            "map1 MAP(ENUM(a)), " +
            "map2 MAP(ENUM(b)), " +
            "PRIMARY KEY(name))";

        /* Collection of record.  Make sure name generation works */
        final String collectionOfRecord =
            "CREATE TABLE recordTable(name STRING, " +
            "arr ARRAY(RECORD(a INTEGER)), " +
            "arr1 ARRAY(RECORD(b INTEGER)), PRIMARY KEY(name))";

        /* Collection of map. Generation not needed */
        final String collectionOfMap =
            "CREATE TABLE mapTable(name STRING, " +
            "arr ARRAY(MAP(INTEGER)), PRIMARY KEY(name))";

        /* duplicate "normal" field names are fine */
        final String dupOK =
            "CREATE TABLE users(name STRING, bin BINARY(4), " +
            "nested RECORD(name STRING), " +
            " PRIMARY KEY(name))";

        /* test if not exists with varying keys */
        final String shardedTable =
            "CREATE TABLE Sharded" +
            "(firstName STRING, lastName STRING, PRIMARY KEY (SHARD(lastName), firstName))";
        final String shardedTable1 =
            "CREATE TABLE IF NOT EXISTS Sharded" +
            "(firstName STRING, lastName STRING, PRIMARY KEY (lastName))";
        final String shardedTable2 =
            "CREATE TABLE IF NOT EXISTS Sharded" +
            "(firstName STRING, lastName STRING, PRIMARY KEY (lastName, firstName))";

        /*
         * Create a sharded table, then test if not exists on what appear to be
         * duplicate tables but differ in keys.
         */
        @SuppressWarnings("unused")
        DdlHandler ddl = executeStatement(shardedTable, true);
        /* these should fail */
        ddl = executeStatement(shardedTable1, false);
        ddl = executeStatement(shardedTable2, false);

        ddl = executeStatement(dupRecord, true);
        ddl = executeStatement(dupEnum, true);
        ddl = executeStatement(dupFixedBinary, true);
        ddl = executeStatement(dupMixedType, true);

        /*
         * These statements test generation of names in collections
         * (maps, arrays) for the field types that require it for
         * schema generation (record, enum, fixed binary).
         */
        ddl = executeStatement(collectionOfRecord, true);
        ddl = executeStatement(collectionOfMap, true);
        // displayTable("mapTable");
        ddl = executeStatement(collectionOfBinary, true);
        // displayTable("binaryTable");
        ddl = executeStatement(collectionOfEnum, true);
        // displayTable("enumTable");

        ddl = executeStatement(dupOK, true);
        // displayTable("users");
    }

    @Test
    public void testComplexIndexes() {
        final String complexTable =
            "CREATE TABLE users(id INTEGER, PRIMARY KEY (id)," +
            "addresses MAP(RECORD(city STRING, street STRING))," +
            "mapOfInt MAP(INTEGER), arrayOfRec ARRAY(RECORD(ifield INTEGER, " +
            "sfield STRING)))";
        final String mapIndex1 =
            "CREATE INDEX map1 ON users (mapOfInt.KEYS(), mapOfInt.VALUES())";
        final String mapIndex2 =
            "CREATE INDEX map2 ON users (addresses.values().city, " +
            "addresses.values().street)";
        final String arrayIndex1 =
            "CREATE INDEX array1 ON users (arrayOfRec[].ifield)";

        /* display anonymous fields */

        final String disp0 =
            "DESCRIBE AS JSON TABLE users";
        final String disp1 =
            "DESCRIBE AS JSON TABLE users (addresses.values())";
        final String disp2 =
            "DESCRIBE AS JSON TABLE users (arrayOfRec[].sfield)";
        final String disp3 =
            "DESCRIBE AS JSON TABLE users (addresses.values().street)";
        /* verify that the ELEMENTOF [] syntax works correctly */
        final String disp4 =
            "DESCRIBE AS JSON TABLE users (arrayOfRec[])";

        /*
         * NOTE: this works.  Technically it should not but compatibility
         * with old map indexes may require it.
        final String disp5 =
            "DESCRIBE AS JSON TABLE users (addresses.FOO.street)";
         */

        @SuppressWarnings("unused")
        DdlHandler ddl = executeStatement(complexTable, true);
        ddl = executeStatement(mapIndex1, true);
        ddl = executeStatement(mapIndex2, true);
        ddl = executeStatement(arrayIndex1, true);

        ddl = executeStatement(disp0, true);
        ddl = executeStatement(disp1, true);
        ddl = executeStatement(disp2, true);
        ddl = executeStatement(disp3, true);
        ddl = executeStatement(disp4, true);
        /* ddl = executeStatement(disp5, false); */
    }

    @Test
    public void testSystemTableDdl() {
        final String testTable = TableStatsPartitionDesc.TABLE_NAME;

        final String createsys = "CREATE TABLE " + testTable + "(id INTEGER," +
            "    json JSON, primary key (id) )";
        final String createsysChild = "CREATE TABLE " +
            testTable + ".foo (id INTEGER," +
            "    json JSON, primary key (id) )";
        final String createsysParent = "CREATE TABLE foo." +
            testTable + " (id INTEGER," +
            "    json JSON, primary key (id) )";
        final String createError = "Can not create table with name prefix " +
            "'" + Translator.SYS_PREFIX + "':";

        final String altersys = "ALTER TABLE " + testTable +
            " (DROP tableSize)";
        final String altersysChild = "ALTER TABLE " + testTable +
            ".foo (DROP tableSize)";
        final String altersysParent = "ALTER TABLE foo." + testTable +
            " (DROP tableSize)";
        final String alterError = "Can not ALTER system table:";

        final String dropsys = "DROP TABLE " + testTable;
        final String dropError = "Cannot remove system table:";

        final String addindex = "CREATE INDEX idx1 on " + testTable +
                                " ( tableSize )";
        final String addIdxError = "Cannot add index idx1 on system table: " +
            testTable;

        final String showindexes = "SHOW INDEXES on " + testTable;
        final String dropindex = "DROP INDEX idx1 on " + testTable;
        final String dropIdxError =
            "Index idx1 does not exists in table " + testTable;

        final String showsys = "SHOW TABLE " + testTable;
        final String descsys = "DESC TABLE " + testTable;

        DdlHandler ddl = executeStatement(createsys, false);
        assertTrue(ddl.getErrorMessage().contains(createError));

        ddl = executeStatement(createsysChild, false);
        assertTrue(ddl.getErrorMessage().contains(createError));

        ddl = executeStatement(createsysParent, false);
        assertTrue(ddl.getErrorMessage().contains(createError));

        ddl = executeStatement(altersys, false);
        assertTrue(ddl.getErrorMessage().contains(alterError));

        ddl = executeStatement(altersysChild, false);
        assertTrue(ddl.getErrorMessage().contains(alterError));

        ddl = executeStatement(altersysParent, false);
        assertTrue(ddl.getErrorMessage().contains(alterError));

        ddl = executeStatement(dropsys, false);
        assertTrue(ddl.getErrorMessage().contains(dropError));

        executeStatement(showindexes, true);

        ddl = executeStatement(addindex, false);
        assertTrue(ddl.getErrorMessage().contains(addIdxError));

        ddl = executeStatement(dropindex, false);
        assertTrue(ddl.getErrorMessage().contains(dropIdxError));

        ddl = executeStatement(showsys, true);
        assertTrue(ddl.getResultString().contentEquals("tableHierarchy\n" +
            "  SYS$TableStatsPartition"));

        ddl = executeStatement(descsys, true);
        assertTrue(ddl.getResultString().contains("SYS$TableStatsPartition"));
    }

    private TableImpl assertTableExists(String tableName, boolean exists) {
        boolean tableExists = false;
        TableMetadata metadata = admin.getTableMetadata();
        TableImpl table = metadata.getTable(null, tableName);
        tableExists = (table != null);
        if (tableExists != exists) {
            fail("Table should" + (exists ? " " : " not") +
                 " exist and it " + (tableExists ? "does: " : "does not: ") +
                 tableName);
        }
        return table;
    }

    private FieldDef assertFieldExists(String tableName, String fieldName,
                                       boolean exists) {
        boolean fieldExists = false;
        TableImpl table = assertTableExists(tableName, true);
        /*
         * Note: findTableField() is an internal method that accepts dot
         * notation for nested fields.
         */
        FieldDef field = table.findTableField(fieldName);
        fieldExists = (field != null);
        if (fieldExists != exists) {
            fail("Field should" + (exists ? " " : " not") +
                 " exist and it " + (fieldExists ? "does: " : "does not: ") +
                 fieldName);
        }
        return field;
    }

    private Index assertIndexExists(String tableName, String indexName,
                                    boolean exists) {
        boolean indexExists = false;
        TableMetadata metadata = admin.getTableMetadata();
        TableImpl table = metadata.getTable(null, tableName);
        Index index = null;
        if (table != null) {
            index = table.getIndex(indexName);
            indexExists = (index != null);
        }

        if (indexExists != exists) {
            fail("Index should" + (exists ? " " : " not") +
                 " exist and it " + (indexExists ? "does: " : "does not: ") +
             tableName + ":" + indexName);
        }
        return index;
    }

    private void assertTableComment(String tableName, String comment) {
        TableImpl table = assertTableExists(tableName, true);
        assertTrue("Mismatched table comment",
                   comment.equals(table.getDescription()));
    }

    private DdlHandler executeStatement(String statement,
                                        boolean shouldSucceed) {
        return executeStatement(statement, null, shouldSucceed);
    }

    private DdlHandler executeStatement(String statement,
                                        String namespace,
                                        boolean shouldSucceed) {
        DdlHandler ddl = new DdlHandler(statement, admin, namespace,
                                        true /* validateNamespace */,
                                        null /* TableLimits */,
                                        null /* AccessChecker */);

        if ( ddl.hasPlan() ) {
            Plan.State status = admin.awaitPlan(ddl.getPlanId(), 0, null);
            if ( status == Plan.State.SUCCEEDED ) {
                assertTrue("Plan for stmt: '" + statement + "' " +
                    "should have " + (shouldSucceed ? "succeeded." : "failed.")
                    , shouldSucceed);
            } else {
                String failInfo = "Plan failed for statement: " + statement + ": " +
                getPlanErrorInfo(ddl.getPlanId());
                assertFalse(failInfo,shouldSucceed);
            }
        } else {
            assertTrue(ddl.getErrorMessage() + ": " + statement,
                ddl.getSuccess() == shouldSucceed);
        }

        return ddl;
    }

    private String getPlanErrorInfo(int planId) {
        ExecutionInfo info = admin.getExecutionStatus(planId,
                                                      SerialVersion.CURRENT);
        return info.getErrorMessage();
    }

    private void removeAllTables() {
        TableMetadata metadata = admin.getTableMetadata();
        final String drop = "DROP TABLE IF EXISTS ";
        for (String table : metadata.listTables(null, true /* allTables */)) {
            if (table.startsWith(TableImpl.SYSTEM_TABLE_PREFIX)) {
                continue;
            }
            executeStatement((drop + table), true);
        }

        /* re-fetch */
        metadata = admin.getTableMetadata();

        /* no user table exists */
        int total = 0;
        for (Table table : metadata.getTables().values()) {
            if (!((TableImpl)table).isSystemTable()) {
                total++;
            }
        }
        assertTrue(total == 0);

    }

    /**
     * Debugging use only.  It is not private in order to avoid warnings when
     * not used.
     */
    void displayTable(String tableName) {
        String qry = "DESCRIBE AS JSON TABLE " + tableName;
        DdlHandler ddl = executeStatement(qry, true);
        System.out.println(ddl.getResultString());
    }

    /*
     * Static methods.  Some could be moved to a shared file for reuse.
     */
    static private void runStaticSetup()
        throws Exception {

        AdminServiceParams adminServiceParams = atc.getParams();

        admin = new Admin(adminServiceParams);

        /* Deploy a Datacenter */
        deployDatacenter();

        /* Deploy SNs and Admin */
        deployStorageNodesAndAdmin();

        /* Deploy the store */
        deployStore();
    }

    static private void deployDatacenter() {
        int id = admin.getPlanner().
            createDeployDatacenterPlan("deploy data center", "Miami", 3,
                                       DatacenterType.PRIMARY, false, false);
        runPlan(id);
    }

    static private void deployStorageNodesAndAdmin() {

        DatacenterId dcid = new DatacenterId(1);
        boolean deployedAdmin = false;
        for (StorageNodeAgent sna : snas) {
            StorageNodeParams snp = new StorageNodeParams
                (sna.getHostname(), sna.getRegistryPort(), null);
            int id = admin.getPlanner().
                createDeploySNPlan("Deploy SN", dcid, snp);
            runPlan(id);

            if (!deployedAdmin) {
                deployAdmin();
                deployedAdmin = true;
            }
        }
    }

    static private void deployAdmin() {
        int id = admin.getPlanner().createDeployAdminPlan
            ("Deploy Admin", snas[0].getStorageNodeId());
        runPlan(id);
    }

    static private void deployStore() {
        admin.createTopoCandidate("DDL", Parameters.DEFAULT_POOL_NAME,
                                  10, false,
                                  SerialVersion.ADMIN_CLI_JSON_V1_VERSION);
        int id = admin.getPlanner().createDeployTopoPlan("Deploy Store", "DDL",
                                                         null);
        runPlan(id);
    }

    static private void runPlan(int planId) {

        admin.approvePlan(planId);
        admin.executePlan(planId, false);
        admin.awaitPlan(planId, 0, null);
        admin.assertSuccess(planId);
    }

    static private void initStorageNodes()
        throws Exception {

        snas = new StorageNodeAgent[numSNs];
        portFinders = new PortFinder[numSNs];
        int port = startPort;

        for (int i = 0; i < snas.length; i++) {
            portFinders[i] = new PortFinder(port, haRange);
            snas[i] = StorageNodeUtils.createUnregisteredSNA
                (TestUtils.getTestDir().toString(),
                 portFinders[i], 1, ("config" + i + ".xml"),
                 false, /* useThreads */
                 true,  /* create admin */
                 null, 0, 0, 1024, null, null);
            port += 10;
        }
    }
}
